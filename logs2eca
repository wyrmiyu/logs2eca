#!/usr/bin/env python3
import os
import sys
import re
import time
import signal
import subprocess
import argparse
import pyinotify
import uuid
from pathlib import Path
from typing import Pattern

# Constants
RE_INDICATORS = ('/', '|', '%')

def parse_args():
    """
    This function parses the command line arguments. It will return a
    argparse.Namespace object, which has attributes
    that correspond to the command line arguments.
    returns: logfile, pattern, command, wait
    """

    desc = ('Monitor a log file for events and run a command when an event '
            'is detected.')
    epilogue = ('The pattern can be a string or a regular expression. If it '
                'is a string, it can be a substring of a line or a word in '
                'a line. Regular expressions must be enclosed in any of the '
                'following characters: /, |, %')
    arg_parser = argparse.ArgumentParser(description=desc,
                                        epilog=epilogue,
                                        add_help=False)
    required = arg_parser.add_argument_group('Required arguments')
    optional = arg_parser.add_argument_group('Optional arguments')

    help_text = {
        'logfile': 'The log file to monitor for events',
        'pattern': 'The pattern to match in the log file',
        'command': 'The command to run when an event is detected',
        'wait': 'The number of seconds to wait before resuming monitoring the log file after an event has been detected. Defaults to 3'
    }

    env_vars = {
        'logfile': 'LOGS2ECA_LOG_FILE',
        'pattern': 'LOGS2ECA_EVENT_PATTERN',
        'command': 'LOGS2ECA_COMMAND',
        'wait': 'LOGS2ECA_WAIT'
    }

    for arg, env_var in env_vars.items():
        required_val = required if arg in ['logfile', 'pattern', 'command'] else optional
        default_val = os.getenv(env_vars[arg]) if os.getenv(env_vars[arg]) else None if arg in ['logfile', 'pattern', 'command'] else 3

        required_val.add_argument('--' + arg, '-'+ arg[0],
                            help= f'{help_text[arg]}. Can be omitted if provided with the environment variable: {env_vars[arg]}',
                            dest=arg,
                            metavar='FILE' if arg == 'logfile' else 'STRING|REGEX' if arg == 'pattern' else 'CMD' if arg == 'command' else 'int',
                            type=str if arg != 'wait' else int,
                            default=default_val)

    optional.add_argument('--help', '-h',
                            help='Show this help message and exit',
                            action='help',
                            default=argparse.SUPPRESS)
    args = arg_parser.parse_args()

    missing_args = [arg for arg, env_var in env_vars.items() if not getattr(args, arg)]
    if missing_args:
        print(f'[error] The following arguments were not specified: {", ".join(missing_args)}')
        arg_parser.print_help()
        exit(1)

    return args

class EventHandler(pyinotify.ProcessEvent):
    """
    pyinoify.ProcessEvent is a class that handles events triggered by the
    pyinotify.WatchManager. It has methods for handling different types
    of events. We will be using the following methods:
        process_IN_MODIFY  - triggered when the log file is modified
        process_IN_CREATE  - triggered when the log file is created
        process_IN_DELETE  - triggered when the log file is deleted
        process_IN_MOVED_FROM - triggered when the log file is moved
    """

    def my_init(self, logfile, pattern, command, wait):
        """
        This method is called by __init__ and is meant for user-defined
        initialization. It sets up the logfile, pattern, command, and wait
        attributes. It also sets up the file attribute, which is a file
        handle to the logfile, and the current_position attribute, which is
        the current position of the file handle. If the logfile does not
        exist, it will set the file attribute to None, and the current
        position to 0.
        """

        self.logfile = Path(logfile).absolute()
        self.pattern = pattern
        self.command = command
        self.wait = wait
        # Create an unique id for the logs2eca instance to distinct it from
        # other instances, the format is: <UUID>, where UUID is
        # a 8 letter hexadecimal string generated by uuid.uuid4()
        self.id = f"<{uuid.uuid4().hex[:8]}>"

        if(self.logfile.exists()):
            print(f"{self.id} Logfile '{self.logfile}' exists")
            self.current_position = self.logfile.stat().st_size
            self.file = open(self.logfile, 'a+')
            self.file.seek(self.current_position)
        else:
            print(f"[warn] Logfile '{self.logfile}' does not exist, "
                "will wait for it to be created.")
            self.file = None
            self.current_position = 0

        # The check whether Pattern is a string or a re.compile object.
        if(isinstance(self.pattern, Pattern)):
            self.pattern_match = lambda line: self.pattern.search(line)
        else:
            self.pattern_match = lambda line: self.pattern in line

    def process_IN_MODIFY(self, event):
        """
        This method will read the log file from the lastknown position to the
        end of the file, and if the pattern is found in any of the lines, it
        will call the run_command method.
        """

        if(Path(event.pathname) == self.logfile):
            if(self.file):
                self.file.seek(self.current_position)
                for line in self.file:
                    if(self.id in line):
                        continue
                    if(self.pattern_match(line)):
                        print(f"{self.id} Event: {line.strip()}")
                        if isinstance(self.pattern, Pattern):
                            info = (f"{self.id} Matching the regex pattern: "
                                    f"{self.pattern.pattern}")
                            print(info)
                        else:
                            print(f"{self.id} Matching the pattern: {self.pattern}")
                        self.run_command()
                self.current_position = self.file.tell()

    def process_IN_CREATE(self, event):
        """
        This method will close the current file handle (if any), open a new
        one, and reset the current position to 0.
        """

        if(Path(event.pathname) == self.logfile):
            print(f"{self.id} Logfile '{self.logfile}' created")
            self.file = open(self.logfile, 'a+')
            self.current_position = 0

    def process_IN_DELETE(self, event):
        """
        Handles IN_DELETE events, which are triggered when the log file is
        deleted. This method will close the current file handle, and set it to
        None, and reset the current position to 0.
        """

        if(Path(event.pathname) == self.logfile):
            print( f"{self.id} Logfile '{self.logfile}' deleted, "
                    "closing and waiting for it to be re-created.")
            if(self.file):
                self.file.close()
            self.file = None

    def process_IN_MOVED_FROM(self, event):
        """
        This method will run the command specified by the user. It will print
        the command to stdout, and then run it using the subprocess module.
        It will then sleep for the number of seconds specified by the user.
        """

        if(Path(event.pathname) == self.logfile):
            print( f"{self.id} Logfile '{self.logfile}' moved, "
                    "closing and waiting for it to be re-created.")
            if(self.file):
                self.file.close()
            self.file = None

    def run_command(self):
        """
        This method will run the command specified by the user. It will print
        the command to stdout, and then run it using the subprocess module.
        It will then sleep for the number of seconds specified by the user.
        """

        print(f"{self.id} Running command: '{self.command}'")
        try:
            result = subprocess.run(self.command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

            # Print the output of the command
            if result.stdout:
                print(f"Command stdout: {result.stdout.decode('utf-8')}")
            if result.stderr:
                print(f"Command stderr: {result.stderr.decode('utf-8')}", file=sys.stderr)
        except subprocess.CalledProcessError as e:
            print(f"Command failed with error {e}")

        time.sleep(self.wait)

    def __del__(self):
        """
        Handles SIGHUP signals. This method will close the current file handle
        (if any), open a new one, and reset the current position to 0.
        """
        if(self.file):
            self.file.close()

class LogFileMonitor:
    """
    This class is the main class of the program. It will parse the command
    line arguments, and then create an instance of the EventHandler class,
    and then start the pyinotify.Notifier.
    """
    def __init__(self):
        """
        This method will declare the handler attribute, which is an instance
        of the EventHandler class.
        """
        self.handler = None

    def handle_sighup(self, signal, frame):
        """
        Handles SIGHUP signals. This method will close the current file handle
        (if any), open a new one, and reset the current position to 0.
        """
        print("[info] Received SIGHUP")
        if self.handler and self.handler.file:
            self.handler.file.close()
            self.handler.file = open(self.handler.logfile, 'r')
            self.handler.current_position = 0

    def run(self):
        args = parse_args()
        signal.signal(signal.SIGHUP, self.handle_sighup)
        pattern = args.pattern.strip()
        for indicator in RE_INDICATORS:
            if(pattern.startswith(indicator) and pattern.endswith(indicator)):
                pattern = re.compile(pattern[1:-1])
                break

        wm = pyinotify.WatchManager()
        self.handler = EventHandler( logfile=args.logfile.strip(),
                                pattern=pattern,
                                command=args.command.strip(),
                                wait=args.wait)
        notifier = pyinotify.Notifier(wm, self.handler)
        wm.add_watch(str(Path(args.logfile).parent), pyinotify.ALL_EVENTS)
        notifier.loop()

if(__name__ == "__main__"):
    monitor = LogFileMonitor()
    monitor.run()
